<!DOCTYPE html>
<!-- 변경 의도: 메뉴 데이터를 활용한 메뉴판 페이지 구축 및 주말 한정 메뉴 노출 -->
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lilliput - 메뉴판</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
        'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      margin: 0;
      background-color: #f9f5ee;
      color: #3c2a1e;
    }

    .container {
      width: 100vw;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 6rem 1rem 6rem;
    }

    .content {
      width: 100%;
      max-width: 1100px;
    }

    .lang-buttons {
      position: fixed;
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-wrap: nowrap;
      gap: 0.6rem;
      padding: 0.4rem 0.8rem;
      background-color: rgba(255, 255, 255, 0.95);
      border-radius: 999px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      max-width: calc(100vw - 1.5rem);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
    }

    .lang-buttons::-webkit-scrollbar {
      height: 4px;
    }

    .lang-buttons::before,
    .lang-buttons::after {
      content: '';
      display: none;
    }

    .lang-btn {
      flex: 0 0 auto;
      margin: 0 0.3rem;
      padding: 0.4rem 0.8rem;
      border: 1px solid #ccc;
      background-color: #fff;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
    }

    .lang-btn:hover {
      background-color: #f5f5f5;
    }

    .lang-btn.active {
      border: 2px solid #b35c38;
      background-color: #fff5ef;
      font-weight: bold;
    }

    h1 {
      text-align: center;
      color: #3c2a1e;
      font-size: 2rem;
      margin-bottom: 1.5rem;
      letter-spacing: 0.02em;
    }

    .type-chips,
    .subcategory-chips {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.6rem;
      margin-bottom: 1.4rem;
      position: relative;
    }

    .type-chips::before,
    .type-chips::after,
    .subcategory-chips::before,
    .subcategory-chips::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      width: 0.9rem;
      pointer-events: none;
      z-index: 1;
      display: none;
    }

    .chip-row {
      display: flex;
      gap: 0.5rem;
      width: 100%;
      justify-content: center;
      position: relative;
      flex-wrap: nowrap;
    }

    .chip-row.scrollable {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      justify-content: center;
      scroll-snap-type: x mandatory;
      white-space: nowrap;
    }

    .chip-row.scrollable::-webkit-scrollbar {
      display: none;
    }

    .chip-row.scrollable {
      scrollbar-width: none;
    }

    .chip-row.scrollable .chip {
      scroll-snap-align: center;
      flex: 0 0 auto;
    }

    .chip {
      padding: 0.45rem 1.2rem;
      border: 1px solid #b35c38;
      background-color: #fff;
      color: #b35c38;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.95rem;
      transition: all 0.2s;
    }

    .chip:hover {
      background-color: #fff0e9;
    }

    .chip.active {
      background-color: #b35c38;
      color: #fff;
      box-shadow: 0 4px 10px rgba(179, 92, 56, 0.3);
      border-color: #b35c38;
    }

    .menu-list {
      display: grid;
      gap: 1.2rem;
    }

    .menu-card {
      background-color: #fff;
      border-radius: 16px;
      padding: 1.2rem 1.4rem;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
      border: 1px solid rgba(179, 92, 56, 0.08);
      position: relative;
      overflow: visible;
      transform-origin: center;
    }

    .menu-card-header {
      display: flex;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 0.8rem;
    }

    .menu-name {
      font-size: 1.15rem;
      font-weight: 600;
      color: #3c2a1e;
    }

    .menu-price {
      font-weight: 600;
      color: #b35c38;
      white-space: nowrap;
    }

    .menu-subtitle {
      font-size: 0.9rem;
      color: #7a5b46;
      margin-bottom: 0.6rem;
    }

    .menu-prices {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-bottom: 0.7rem;
    }

    .new-badge {
      position: absolute;
      top: -1.3rem;
      left: -1.3rem;
      width: 68px;
      height: auto;
      pointer-events: none;
      user-select: none;
      z-index: 1;
    }

    @keyframes menu-card-shake {
      0% {
        transform: rotate(0deg);
      }
      15% {
        transform: rotate(-2deg);
      }
      30% {
        transform: rotate(2deg);
      }
      45% {
        transform: rotate(-1.5deg);
      }
      60% {
        transform: rotate(1.5deg);
      }
      75% {
        transform: rotate(-1deg);
      }
      100% {
        transform: rotate(0deg);
      }
    }

    .menu-card.new-shake-active {
      animation: menu-card-shake 1.3s ease-in-out;
    }

    .price-tag {
      padding: 0.3rem 0.7rem;
      border-radius: 999px;
      background-color: #fff5ef;
      color: #9f4f31;
      font-size: 0.85rem;
      border: 1px solid rgba(179, 92, 56, 0.2);
    }

    .menu-ingredients {
      font-size: 0.85rem;
      color: #5b4a3f;
      line-height: 1.5;
    }

    .menu-notes {
      font-size: 0.85rem;
      color: #9f4f31;
      margin-top: 0.5rem;
    }

    .empty-state {
      text-align: center;
      padding: 2rem 1rem;
      border-radius: 12px;
      background-color: rgba(255, 255, 255, 0.8);
      color: #7a5b46;
      border: 1px dashed rgba(179, 92, 56, 0.3);
      margin-top: 2rem;
    }

    .guide-btn {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.75rem 1.6rem;
      background-color: #b35c38;
      color: #fff;
      border: none;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: bold;
      text-decoration: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: background-color 0.2s, transform 0.2s;
      z-index: 1000;
    }

    .guide-btn:hover {
      background-color: #9f4f31;
    }

    .guide-btn:active {
      transform: translateX(-50%) scale(0.98);
    }

    @media (min-width: 720px) {
      .menu-list {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 520px) {
      .container {
        padding-top: 7rem;
        padding-bottom: 7rem;
      }

      .lang-buttons {
        width: min(280px, 70vw);
        gap: 0.35rem;
        padding: 0.25rem 0.8rem;
        scroll-snap-type: x mandatory;
        scrollbar-width: none;
      }

      .lang-buttons::-webkit-scrollbar {
        display: none;
      }

      .lang-buttons::before,
      .lang-buttons::after {
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        width: 0.9rem;
        pointer-events: none;
        z-index: 2;
      }

      .lang-buttons::before {
        left: 0;
        background: linear-gradient(90deg, rgba(249, 245, 238, 0.95), rgba(249, 245, 238, 0));
      }

      .lang-buttons::after {
        right: 0;
        background: linear-gradient(270deg, rgba(249, 245, 238, 0.95), rgba(249, 245, 238, 0));
      }

      .chip-row.scrollable {
        justify-content: flex-start;
      }

      .type-chips::before,
      .subcategory-chips::before {
        left: 0;
        background: linear-gradient(90deg, rgba(249, 245, 238, 0.9), rgba(249, 245, 238, 0));
        display: block;
      }

      .type-chips::after,
      .subcategory-chips::after {
        right: 0;
        background: linear-gradient(270deg, rgba(249, 245, 238, 0.9), rgba(249, 245, 238, 0));
        display: block;
      }

      .lang-btn {
        padding: 0.32rem 0.7rem;
        margin: 0 0.2rem;
        font-size: 0.9rem;
        scroll-snap-align: center;
      }

      .menu-card {
        padding: 1rem 1.1rem;
      }

      .menu-name {
        font-size: 1.05rem;
      }

      .menu-price {
        font-size: 0.95rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="content">
      <div class="lang-buttons">
        <button class="lang-btn" data-lang="ko">한국어</button>
        <button class="lang-btn" data-lang="en">English</button>
        <button class="lang-btn" data-lang="ja">日本語</button>
        <button class="lang-btn" data-lang="zh">中文</button>
      </div>

      <h1 id="page-title">메뉴판</h1>

      <div class="type-chips">
        <div class="chip-row scrollable" id="type-chips"></div>
      </div>
      <div class="subcategory-chips">
        <div class="chip-row scrollable" id="subcategory-chips"></div>
      </div>

      <div id="menu-list" class="menu-list"></div>
      <div id="empty-state" class="empty-state" hidden>표시할 메뉴가 없습니다.</div>
    </div>
  </div>

  <a class="guide-btn" id="guide-btn" href="guide.html" aria-label="이용 안내 페이지 바로가기">이용 안내 보기</a>

  <script>
    const MENU_PATHS = {
      foods: 'src/data/menu/menu_foods.json',
      drinks: 'src/data/menu/menu_drinks.json',
    };

    const LANGUAGE_FALLBACK = 'en';

    const textBundle = {
      ko: {
        pageTitle: '메뉴판',
        typeLabels: { foods: '음식', drinks: '음료' },
        all: '전체',
        ingredients: '주요 재료',
        hot: 'HOT',
        ice: 'ICE',
        single: '단일',
        empty: '표시할 메뉴가 없습니다.',
        back: '이용 안내 보기',
        loading: '메뉴를 불러오는 중입니다...',
        loadError: '메뉴 데이터를 불러오지 못했습니다.',
        newBadgeAlt: '신메뉴 배지 이미지',
      },
      en: {
        pageTitle: 'Menu',
        typeLabels: { foods: 'Food', drinks: 'Drinks' },
        all: 'All',
        ingredients: 'Ingredients',
        hot: 'Hot',
        ice: 'Iced',
        single: 'Single',
        empty: 'No items to display.',
        back: 'View Guide',
        loading: 'Loading menu...',
        loadError: 'Unable to load menu data.',
        newBadgeAlt: 'New menu badge image',
      },
      ja: {
        pageTitle: 'メニュー',
        typeLabels: { foods: 'フード', drinks: 'ドリンク' },
        all: 'すべて',
        ingredients: '主な材料',
        hot: 'ホット',
        ice: 'アイス',
        single: '単品',
        empty: '表示できるメニューがありません。',
        back: '案内を見る',
        loading: 'メニューを読み込み中です...',
        loadError: 'メニューデータを読み込めませんでした。',
        newBadgeAlt: '新メニューを示すバッジ画像',
      },
      zh: {
        pageTitle: '菜单',
        typeLabels: { foods: '餐点', drinks: '饮品' },
        all: '全部',
        ingredients: '主要食材',
        hot: '热',
        ice: '冰',
        single: '单品',
        empty: '暂无可显示的菜单。',
        back: '查看指南',
        loading: '正在载入菜单…',
        loadError: '无法载入菜单数据。',
        newBadgeAlt: '新品徽章图像',
      },
    };

    const categoryLabels = {
      foods: {
        RICE: { ko: '라이스', en: 'Rice', ja: 'ライス', zh: '盖饭' },
        PASTA: { ko: '파스타', en: 'Pasta', ja: 'パスタ', zh: '意面' },
        PIZZA: { ko: '피자', en: 'Pizza', ja: 'ピザ', zh: '披萨' },
        SALAD: { ko: '샐러드', en: 'Salad', ja: 'サラダ', zh: '沙拉' },
        SNACKS: { ko: '스낵', en: 'Snacks', ja: 'スナック', zh: '小食' },
        STEAK: { ko: '스테이크', en: 'Steak', ja: 'ステーキ', zh: '牛排' },
        OTHER: { ko: '기타', en: 'Other', ja: 'その他', zh: '其他' },
      },
      drinks: {
        ESPRESSO: { ko: '에스프레소', en: 'Espresso', ja: 'エスプレッソ', zh: '浓缩咖啡' },
        LATTE: { ko: '라떼', en: 'Latte', ja: 'ラテ', zh: '拿铁' },
        COLD_BREW: { ko: '콜드브루', en: 'Cold Brew', ja: 'コールドブリュー', zh: '冷萃咖啡' },
        FRUIT_TEA: { ko: '과일 티', en: 'Fruit Tea', ja: 'フルーツティー', zh: '水果茶' },
        TEA: { ko: '티', en: 'Tea', ja: '紅茶', zh: '茶' },
        FRESH_JUICE: { ko: '생과일 주스', en: 'Fresh Juice', ja: 'フレッシュジュース', zh: '鲜榨果汁' },
        LILLY_CCINO: { ko: '릴리치노', en: 'Lilly-ccino', ja: 'リリーシーノ', zh: 'Lilly-ccino' },
        SODA: { ko: '소다/에이드', en: 'Soda & Ade', ja: 'ソーダ・エイド', zh: '汽水/气泡饮' },
        BEER: { ko: '맥주', en: 'Beer', ja: 'ビール', zh: '啤酒' },
        WINE: { ko: '와인', en: 'Wine', ja: 'ワイン', zh: '葡萄酒' },
        OTHER_BEVERAGE: { ko: '기타 음료', en: 'Other Drinks', ja: 'その他ドリンク', zh: '其他饮品' },
        OTHER: { ko: '기타', en: 'Other', ja: 'その他', zh: '其他' },
      },
    };

    const STORAGE_KEY = 'lilliputPreferredLang';
    const WEEKEND_ONLY_FOOD_NAMES = new Set([
      'tiramisu',
      '티라미수',
      'ティラミス',
      '提拉米苏',
    ]);

    const WEEKDAY_ONLY_FOOD_NAMES = new Set([
      'teriyaki chicken potato risotto',
      '데리야끼 치킨 감자 리조또',
      '照り焼きチキンとポテトのリゾット',
      '照烧鸡土豆烩饭',
      'chicken cobb salad',
      '치킨 콥 샐러드',
      'チキンコブサラダ',
      '鸡肉科布沙拉',
    ]);
    const NEW_BADGE_ANIMATION_MS = 1300;
    const NEW_BADGE_COOLDOWN_MS = 10000;
    let newBadgeObserver = null;
    const newBadgeLastTriggered = new WeakMap();

    const state = {
      menu: { foods: [], drinks: [] },
      currentType: 'foods',
      currentSubcategory: 'ALL',
      currentLang: loadPreferredLanguage(),
      loadError: false,
    };

    const typeChipsContainer = document.getElementById('type-chips');
    const subcategoryChipsContainer = document.getElementById('subcategory-chips');
    const menuListElement = document.getElementById('menu-list');
    const emptyStateElement = document.getElementById('empty-state');
    const titleElement = document.getElementById('page-title');
    const guideButton = document.getElementById('guide-btn');
    const langButtonsContainer = document.querySelector('.lang-buttons');
    const langButtons = document.querySelectorAll('.lang-btn');

    function isWeekendInSeoul() {
      try {
        const weekday = new Intl.DateTimeFormat('en-US', {
          timeZone: 'Asia/Seoul',
          weekday: 'short',
        }).format(new Date());
        return weekday === 'Sat' || weekday === 'Sun';
      } catch (error) {
        console.warn('주말 판별에 실패했습니다.', error);
        const today = new Date().getDay();
        return today === 0 || today === 6;
      }
    }

    function isWeekendOnlyFood(item) {
      if (!item || typeof item !== 'object') {
        return false;
      }
      const names = [item.name_en, item.name_ko, item.name_ja, item.name_zh];
      return names.some(
        name => typeof name === 'string' && WEEKEND_ONLY_FOOD_NAMES.has(name.trim().toLowerCase()),
      );
    }

    function isWeekdayOnlyFood(item) {
      if (!item || typeof item !== 'object') {
        return false;
      }
      const names = [item.name_en, item.name_ko, item.name_ja, item.name_zh];
      return names.some(
        name => typeof name === 'string' && WEEKDAY_ONLY_FOOD_NAMES.has(name.trim().toLowerCase()),
      );
    }

    function filterTimeLimitedFoods(items) {
      if (!Array.isArray(items)) {
        return [];
      }
      const weekend = isWeekendInSeoul();
      return items.filter(item => {
        if (weekend && isWeekdayOnlyFood(item)) {
          return false;
        }
        if (!weekend && isWeekendOnlyFood(item)) {
          return false;
        }
        return true;
      });
    }

    function triggerNewBadgeAnimation(card) {
      card.classList.remove('new-shake-active');
      // reflow to restart animation
      void card.offsetWidth;
      card.classList.add('new-shake-active');
      setTimeout(() => {
        card.classList.remove('new-shake-active');
      }, NEW_BADGE_ANIMATION_MS);
    }

    function handleNewBadgeIntersection(entries) {
      entries.forEach(entry => {
        if (!entry.isIntersecting) {
          return;
        }
        const card = entry.target;
        const now = Date.now();
        const last = newBadgeLastTriggered.get(card) || 0;
        if (last && now - last < NEW_BADGE_COOLDOWN_MS) {
          return;
        }
        newBadgeLastTriggered.set(card, now);
        triggerNewBadgeAnimation(card);
      });
    }

    function getNewBadgeObserver() {
      if (!newBadgeObserver) {
        newBadgeObserver = new IntersectionObserver(handleNewBadgeIntersection, {
          threshold: 0.45,
        });
      }
      return newBadgeObserver;
    }

    function setupNewBadgeObserver() {
      const observer = getNewBadgeObserver();
      observer.disconnect();
      const cards = document.querySelectorAll('.menu-card[data-new="true"]');
      cards.forEach(card => {
        observer.observe(card);
      });
    }

    function detectLanguage() {
      const browserLang = navigator.language || navigator.userLanguage || '';
      if (browserLang.startsWith('ko')) return 'ko';
      if (browserLang.startsWith('ja')) return 'ja';
      if (browserLang.startsWith('zh')) return 'zh';
      return LANGUAGE_FALLBACK;
    }

    function loadPreferredLanguage() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored && textBundle[stored]) {
          return stored;
        }
      } catch (error) {
        console.warn('언어 설정을 불러오지 못했습니다.', error);
      }
      return detectLanguage();
    }

    function savePreferredLanguage(lang) {
      try {
        localStorage.setItem(STORAGE_KEY, lang);
      } catch (error) {
        console.warn('언어 설정을 저장하지 못했습니다.', error);
      }
    }

    function normalizeKey(key) {
      if (!key) return 'OTHER';
      return key
        .toUpperCase()
        .replace(/[^A-Z0-9]+/g, '_')
        .replace(/^_+|_+$/g, '') || 'OTHER';
    }

    function getCategoryLabel(type, key, lang) {
      const normalized = normalizeKey(key);
      const dictionary = categoryLabels[type] || {};
      const entry = dictionary[normalized] || dictionary.OTHER || { ko: '기타', en: 'Other', ja: 'その他', zh: '其他' };
      const fallback = textBundle[LANGUAGE_FALLBACK];
      return (entry[lang] || fallback.typeLabels?.[type] || entry[LANGUAGE_FALLBACK] || key || normalized);
    }

    function formatPrice(value, lang) {
      if (value === null || value === undefined) {
        return null;
      }
      const amount = Math.round(Number(value) * 1000);
      if (Number.isNaN(amount)) {
        return null;
      }
      if (lang === 'ko') {
        return amount.toLocaleString('ko-KR') + '원';
      }
      const locale = { en: 'en-US', ja: 'ja-JP', zh: 'zh-CN' }[lang] || 'en-US';
      return new Intl.NumberFormat(locale, {
        style: 'currency',
        currency: 'KRW',
        maximumFractionDigits: 0,
      }).format(amount);
    }

    function centerActiveLanguageButton() {
      if (!langButtonsContainer) return;
      const activeButton = langButtonsContainer.querySelector('.lang-btn.active');
      if (activeButton) {
        activeButton.scrollIntoView({ block: 'nearest', inline: 'center', behavior: 'smooth' });
      }
    }

    function centerActiveChip(container) {
      if (!container) return;
      const activeChip = container.querySelector('.chip.active');
      if (activeChip) {
        activeChip.scrollIntoView({ block: 'nearest', inline: 'center', behavior: 'smooth' });
      }
    }

    function getItemName(item, lang) {
      if (lang === 'ko') {
        return item.name_ko || item.name_en || '';
      }
      const key = 'name_' + lang;
      if (item[key]) {
        return item[key];
      }
      if (item.name_en) {
        return item.name_en;
      }
      return item.name_ko || '';
    }

    function updateSubcategory(key) {
      if (state.currentSubcategory === key) {
        return;
      }
      state.currentSubcategory = key;
      renderSubcategoryChips();
      renderMenuCards();
    }

    function renderLanguageButtons() {
      langButtons.forEach(button => {
        const lang = button.dataset.lang;
        if (lang === state.currentLang) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
        if (!button.dataset.bound) {
          button.addEventListener('click', () => {
            state.currentLang = lang;
            document.documentElement.lang = lang;
            savePreferredLanguage(lang);
            render();
          });
          button.dataset.bound = 'true';
        }
      });
      centerActiveLanguageButton();
    }

    function renderTypeChips() {
      const { currentLang, currentType } = state;
      const text = textBundle[currentLang] || textBundle[LANGUAGE_FALLBACK];
      typeChipsContainer.innerHTML = '';

      ['foods', 'drinks'].forEach(type => {
        const chip = document.createElement('button');
        chip.className = 'chip type-chip' + (currentType === type ? ' active' : '');
        chip.dataset.type = type;
        chip.textContent = text.typeLabels[type] || type;
        chip.addEventListener('click', () => {
          if (state.currentType !== type) {
            state.currentType = type;
            state.currentSubcategory = 'ALL';
            render();
          }
        });
        typeChipsContainer.appendChild(chip);
      });

      centerActiveChip(typeChipsContainer);
    }

    function renderSubcategoryChips() {
      const { currentLang, currentType, currentSubcategory } = state;
      const text = textBundle[currentLang] || textBundle[LANGUAGE_FALLBACK];
      const items = state.menu[currentType] || [];

      const subcategories = Array.from(new Set(items.map(item => {
        if (currentType === 'foods') {
          return item.category;
        }
        return item.subcategory || item.category;
      }))).filter(Boolean);

      subcategoryChipsContainer.innerHTML = '';

      if (!items.length) {
        return;
      }

      const allChip = document.createElement('button');
      allChip.className = 'chip subcategory-chip' + (currentSubcategory === 'ALL' ? ' active' : '');
      allChip.dataset.subcategory = 'ALL';
      allChip.textContent = text.all;
      allChip.addEventListener('click', () => updateSubcategory('ALL'));
      subcategoryChipsContainer.appendChild(allChip);

      subcategories.sort().forEach(subcategory => {
        const key = normalizeKey(subcategory);
        const chip = document.createElement('button');
        chip.className = 'chip subcategory-chip' + (currentSubcategory === key ? ' active' : '');
        chip.dataset.subcategory = key;
        chip.textContent = getCategoryLabel(currentType, key, currentLang);
        chip.addEventListener('click', () => updateSubcategory(key));
        subcategoryChipsContainer.appendChild(chip);
      });

      centerActiveChip(subcategoryChipsContainer);
    }

    function renderMenuCards() {
      const { currentLang, currentType, currentSubcategory } = state;
      const text = textBundle[currentLang] || textBundle[LANGUAGE_FALLBACK];
      if (state.loadError) {
        menuListElement.innerHTML = '';
        emptyStateElement.hidden = false;
        emptyStateElement.textContent = text.loadError;
        return;
      }
      const items = state.menu[currentType] || [];

      const filtered = items.filter(item => {
        if (currentSubcategory === 'ALL') {
          return true;
        }
        const key = currentType === 'foods'
          ? normalizeKey(item.category)
          : normalizeKey(item.subcategory || item.category);
        return key === currentSubcategory;
      });

      menuListElement.innerHTML = '';

      if (!filtered.length) {
        emptyStateElement.hidden = false;
        emptyStateElement.textContent = text.empty;
        return;
      }

      emptyStateElement.hidden = true;

      filtered.forEach(item => {
        const card = document.createElement('div');
        card.className = 'menu-card';
        const isNewItem = Boolean(item.is_new);
        if (isNewItem) {
          card.dataset.new = 'true';
        } else {
          card.dataset.new = 'false';
        }

        if (isNewItem) {
          const badge = document.createElement('img');
          badge.src = 'src/image/new.png';
          badge.alt = text.newBadgeAlt || 'New menu';
          badge.className = 'new-badge';
          badge.loading = 'lazy';
          card.appendChild(badge);
        }

        const header = document.createElement('div');
        header.className = 'menu-card-header';

        const name = document.createElement('h3');
        name.className = 'menu-name';
        const nameValue = getItemName(item, currentLang);
        name.textContent = nameValue;

        const subtitle = document.createElement('div');
        subtitle.className = 'menu-subtitle';
        const subcategoryKey = currentType === 'foods'
          ? item.category
          : item.subcategory || item.category;
        subtitle.textContent = getCategoryLabel(currentType, subcategoryKey, currentLang);

        if (currentType === 'foods') {
          const formatted = formatPrice(item.price, currentLang);
          if (formatted) {
            const price = document.createElement('div');
            price.className = 'menu-price';
            price.textContent = formatted;
            header.appendChild(price);
          }
        }

        header.appendChild(name);
        card.appendChild(header);
        card.appendChild(subtitle);

        if (currentType === 'drinks') {
          const pricesContainer = document.createElement('div');
          pricesContainer.className = 'menu-prices';

          const single = formatPrice(item.single_price, currentLang);
          const hot = formatPrice(item.hot_price, currentLang);
          const ice = formatPrice(item.ice_price, currentLang);

          if (single) {
            const pill = document.createElement('span');
            pill.className = 'price-tag';
            pill.textContent = `${text.single}: ${single}`;
            pricesContainer.appendChild(pill);
          }

          if (hot) {
            const pill = document.createElement('span');
            pill.className = 'price-tag';
            pill.textContent = `${text.hot}: ${hot}`;
            pricesContainer.appendChild(pill);
          }

          if (ice) {
            const pill = document.createElement('span');
            pill.className = 'price-tag';
            pill.textContent = `${text.ice}: ${ice}`;
            pricesContainer.appendChild(pill);
          }

          if (pricesContainer.childElementCount > 0) {
            card.appendChild(pricesContainer);
          }
        }

        if (currentType === 'foods' && Array.isArray(item.ingredients) && item.ingredients.length) {
          const ingredients = document.createElement('div');
          ingredients.className = 'menu-ingredients';
          ingredients.textContent = `${text.ingredients}: ${item.ingredients.join(', ')}`;
          card.appendChild(ingredients);
        }

        if (item.notes) {
          const notes = document.createElement('div');
          notes.className = 'menu-notes';
          notes.textContent = item.notes;
          card.appendChild(notes);
        }

        menuListElement.appendChild(card);
      });
    }

    function render() {
      const { currentLang } = state;
      const text = textBundle[currentLang] || textBundle[LANGUAGE_FALLBACK];

      document.documentElement.lang = currentLang;
      titleElement.textContent = text.pageTitle;
      guideButton.textContent = text.back;
      guideButton.setAttribute('aria-label', text.back);

      renderLanguageButtons();
      renderTypeChips();
      renderSubcategoryChips();
      renderMenuCards();
      setupNewBadgeObserver();
    }

    async function loadMenuData() {
      state.loadError = false;
      try {
        const [foodsRes, drinksRes] = await Promise.all([
          fetch(MENU_PATHS.foods),
          fetch(MENU_PATHS.drinks),
        ]);

        if (!foodsRes.ok || !drinksRes.ok) {
          throw new Error('Failed to load menu data');
        }

        const foods = await foodsRes.json();
        const drinks = await drinksRes.json();

        const foodsArray = Array.isArray(foods) ? foods : [];
        state.menu.foods = filterTimeLimitedFoods(foodsArray);
        state.menu.drinks = Array.isArray(drinks) ? drinks : [];
      } catch (error) {
        console.error(error);
        state.loadError = true;
      }
    }

    async function init() {
      document.documentElement.lang = state.currentLang;
      renderLanguageButtons();
      const currentText = textBundle[state.currentLang] || textBundle[LANGUAGE_FALLBACK];
      const loadingPlaceholder = document.createElement('div');
      loadingPlaceholder.className = 'empty-state';
      loadingPlaceholder.textContent = currentText.loading;
      menuListElement.appendChild(loadingPlaceholder);

      await loadMenuData();
      render();
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>

  <footer style="font-size:0.8rem; color:#999; text-align:center; margin-top:40px;">
    © Lilliput Cheongdam · 본 사이트는 쿠키 및 로컬 저장소를 기능 제공 목적으로만 사용합니다.
  </footer>
</body>
</html>
